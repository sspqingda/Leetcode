# 389. Find the Difference  QuestionEditorial Solution  My Submissions
```
Total Accepted: 12390
Total Submissions: 25881
Difficulty: Easy
Given two strings s and t which consist of only lowercase letters.

String t is generated by random shuffling string s and then add one more letter at a random position.

Find the letter that was added in t.
```


``` html
The Stream.reduce Method

The Stream.reduce method is a general-purpose reduction operation. Consider the following pipeline, which calculates the sum of the male members' ages in the collection roster. It uses the Stream.sum reduction operation:

Integer totalAge = roster
    .stream()
    .mapToInt(Person::getAge)
    .sum();
Compare this with the following pipeline, which uses the Stream.reduce operation to calculate the same value:

Integer totalAgeReduce = roster
   .stream()
   .map(Person::getAge)
   .reduce(
       0,
       (a, b) -> a + b);
The reduce operation in this example takes two arguments:

identity: The identity element is both the initial value of the reduction and the default result if there are no elements in the stream. In this example, the identity element is 0; this is the initial value of the sum of ages and the default value if no members exist in the collection roster.

accumulator: The accumulator function takes two parameters: a partial result of the reduction (in this example, the sum of all processed integers so far) and the next element of the stream (in this example, an integer). It returns a new partial result. In this example, the accumulator function is a lambda expression that adds two Integer values and returns an Integer value:

(a, b) -> a + b
The reduce operation always returns a new value. However, the accumulator function also returns a new value every time it processes an element of a stream. Suppose that you want to reduce the elements of a stream to a more complex object, such as a collection. This might hinder the performance of your application. If your reduce operation involves adding elements to a collection, then every time your accumulator function processes an element, it creates a new collection that includes the element, which is inefficient. It would be more efficient for you to update an existing collection instead. You can do this with the Stream.collect method, which the next section describes.



```



```java

public class Solution {
    public char findTheDifference(String s, String t) {
       return (char) (s + t).chars().reduce(0, (x, y) -> x ^ y);
    }
}
```


``` java

public class Solution {
    public char findTheDifference(String s, String t) {
        HashMap<Character,Integer> map = new HashMap<Character,Integer>();
        for(int i = 0; i<s.length();i++)
        {
            char c = s.charAt(i);
            if(map.containsKey(c)) map.put(c,map.get(c)+1);
            else map.put(c,1);
        }
        for(int j =0; j<t.length();j++)
        {
            char tc = t.charAt(j);
            if(map.containsKey(tc) && map.get(tc)>0) map.put(tc,map.get(tc)-1);
            else 
            {
                return tc;
            }
            
        }
        
        return '-';
    }
}

```
